# Specify the type of service being deployed
# There are can be two types: stateless/stateful
type: stateless

## You can provide this var through commandline --set option:
## --set fullnameOverride=appname
## Default - base.fullname
#fullnameOverride: stubapp

# Available only for stateful mode
# Possible values: OrderedReady/Parallel
podManagementPolicy: OrderedReady

# Available only for stateless mode
# Possible values: RollingUpdate/Recreate
strategyType: RollingUpdate

base: {}
replicaCount: 1

# Enable PodDisruptionBudget to prevent unexpected pod evicitons during nodes draining.
# Useful if running more than 1 replica and dangerous if not.
# Specify on of minAvailable or maxUnavailable. Specifying both is invalid.
# See the k8s 1.18 reference: https://v1-18.docs.kubernetes.io/docs/tasks/run-application/configure-pdb
pdb:
  enabled: false
  # minAvailable: 3
  # maxUnavailable: 1

# Define the pod-level securityContext
podSecurityContext: {}

servicePort: &servicePort 80
targetPort: &targetPort 8080
serviceMonitor: disabled
serviceMonitorMtls: false
serviceType: ClusterIP
additionalServiceNames: []
additionalLabels: {}

#If you want to expose multiple ports
# servicePorts:
#   http:
#     servicePort: *servicePort
#     targetPort: *targetPort
#     serviceMonitor: enabled
#   actuator:
#     servicePort: 8091
#     targetPort: 8091

# For unusual needs
# serviceAnnotations:
#     prometheus.io/path: /metrics
#     prometheus.io/scrape: "true"

nodeSelector: {}

imagePullSecrets: []
## Example:
# - name: regcred

# initContainers: []
## Example:
# - name: init1
#   image: busybox
#   command: ['sh', '-c', 'until nslookup myservice; do echo waiting for myservice; sleep 2; done;']
# - name: init2
#   image: busybox
#   command: ['sh', '-c', 'until nslookup mydb; do echo waiting for mydb; sleep 2; done;']

## Provide service names in same namespace for waiting at list one active endpoint.
## (one Pod with all containers live and ready)
## For this checks k8s api is used
waitFor: []
waitForInitImage: registry.example.com/devops/jq:1.0

# configMapsEnvChangeTriggersRestart: false
# configMapsFromFilesChangeTriggersRestart: false
# configMapsFromVarChangeTriggersRestart: false
# secretEnvChangeTriggersRestart: false
#
## Useful for dev deployment when imageTag is always the same
## (eg. latest) and imagePullPolicy is Always
## but we need to trigger Pod restart to new image been fetched
# additionalPodAnnotations:
#   ci/commithash: deadbeef

containers: {}
#  app:
#    ## appVersion must be defined in parent chart with commandline option
#    appVersion: 1.0.0.rc1-stub
#
#    ## By default container image name generated from imageRegistry, Chart.Name and Release.Name
#    ## You can set image here to override.
#    ## Also you can provide this var through commandline --set option:
#    ## --set container[0].image="registry.example.com/productname/stubapp"
#    image: "registry.example.com/productname/stubapp"
#
#    ## Default imageRegistry, not used if image is defined and non-empty
#    imageRegistry: registry.example.com
#
#    ## imageTag overrides appVersion for image in container spec.
#    ## By default the same as appVersion.
#    # imageTag:
#
#    imagePullPolicy: IfNotPresent
#
#    #env: {}
#    ## Examples
#    # JAVA_OPTS: "-Xms128M -Xmx128M"
#    # YO_DAWG: "I heard you like helm charts so I put a helm chart in your helm chart so you can deploy app while deploying app"
#
#    #extraEnv: {}
#    ## Extra env variables, processed as toYaml
#    - name: JAEGER_AGENT_HOST
#      valueFrom:
#        fieldRef:
#          fieldPath: status.hostIP
#
#    #secretEnv: {}
#    ## You should provide this secrets only from commandline args
#    ## e.g.:
#    ## --set containers.app.secretEnv.firstEnv=${firstValueFromRuntimeEnviron} \
#    ## --set containers.app.secretEnv.secondEnv=${secondValueFromRuntimeEnviron}
#
#    ## Configure all key-value pairs in a ConfigMap or a Secret as container environment variables
#      envFrom: {}
#    ## Examples
#    #  - secretRef:
#    #    name: vault-keys
#    #    optional: true
#
#    # secrets:
#    ### Can mount certs
#    # - name: kafka.client.truststore.jks
#    #   mountPath: /opt/
#    #   optional: false
#
#    resources: {}
#    # Examples
#    # limits:
#    #   memory: 256Mi
#    #   cpu: 250m
#    # requests:
#    #   memory: 256Mi
#    #   cpu: 250m
#
#    containerPort: *targetPort
#
#    #commandOverride: []
#    #argsOverride: []
#
#    ## Overwrite autogenerated hostname for app container in pod for some shitty apps that required this
#    #appPodHostname: some-hostname
#
#    livenessProbe: {}
#    # httpGet:
#    #   path: /
#    #   port: *targetPort
#    # initialDelaySeconds: 20
#    # periodSeconds: 20
#    # failureThreshold: 6
#    readinessProbe: {}
#    # httpGet:
#    #   path: /
#    #   port: *targetPort
#    # initialDelaySeconds: 20
#    # periodSeconds: 20
#    # failureThreshold: 6
#
#    configMapsFromFiles: []
#    ## Format:
#    # - mountPath: <mountPath>
#    #   fileName: <filenameIn'./files'
#    #   defaultMode: <for ex. 0644>
#
#    configMapsFromVar: []
#    ## Format:
#    # - mountPath: <mountPath>
#    #   defaultMode: <for ex. 0644>
#    #   files:
#    #   - name: <encodedFileName>
#    #     encoded: true # set if pre-encoded data supplied
#    #     data: <encodedData>
#    #   - name: <filename>
#    #     data: <data>
#    # - mountPath: <anotherMountPath>
#    #   files:
#    #   - name: <filename>
#    #     data: <data>
#
#    configMapsExisting: []
#    ## Format:
#    # - name: <configMapName>
#    #   defaultMode: <for ex. 0644>
#    #   mountPath: <mountPath>
#
#    ## 'memory: true' for tmpfs mount
#    emptyDirVolumes:
#      cache:
#        memory: false
#        mountPath: /cache
#      memcache:
#        memory: true
#        mountPath: /memcache
#
#    persistence:[]
#    ## Format:
#    # - mountPath: <mountPath>
#    #   fileName: <filenameIn'./files'
#    #   defaultMode: <for ex. 0644>
#
#    ## Define the container-level securityContext
#    securityContext: {}
####

ingress:
  enabled: false
  ingresses: {}
## Define ingresses as following example
## and set enabled to true
#   ingresses:
#     ## Name suffix:
#     external:
#       ## Optional
#       annotations:
#         nginx.ingress.kubernetes.io/rewrite-target: /$2
#         # Deprecated, use ingressClassName
#         kubernetes.io/ingress.class: some-external-ctrl-class
#       ## Optional
#       ingressClassName: nginx
#       rules:
#         - host: external-name.example.com
#           paths:
#             - path: /something(/|$)(.*)
#               ## Optional, default if omitted - `Prefix`
#               pathType: Prefix
#
#               #### Format since 1.19:
#               ## Example 1:
#               backend:
#                 service:
#                   port:
#                     number: *servicePort
#               ## Example 2:
#               backend:
#                 resource:
#                   apiGroup: k8s.example.com
#                   kind: StorageBucket
#                   name: icon-assets
#               #### OR format before 1.19:
#               servicePort: *servicePort
#               ####
#
#       tls:
#         enabled: true
#         ## Omit if `enabled: false`
#         secrets:
#           - secretName: wildcard-example-com-tls
#             hosts:
#               - external-name.example.com

serviceAccount:
  ## Specifies whether a ServiceAccount should be created
  ## Note: It's implicitly created if .Values.waitFor is defined
  ##
  create: false
  ## The name of the ServiceAccount to use.
  ## If not set and create is true, a name is generated using the fullname template
  ##
  # name: ""

rbac:
  role:
    ## Specifies whether RBAC resources should be created
    ## Note: It's implicitly created if .Values.waitFor is defined
    ## Note: Be careful, if you don't set ".Values.serviceAccount.create: true",
    ##       then role will be added to the "default" service account!
    ##
    create: false
    ## Rules to create. It follows the role specification
    ##
    rules: []
    # - apiGroups: [""]
    #   resources: ["pods"]
    #   verbs: ["get", "watch", "list"]
  clusterRole:
    create: false
    rules: []
    ## If `true` will bind clusterRole with ClusterRoleBinding
    ## otherwise will bind it with RoleBinding
    bindWithClusterRoleBinding: false

# Enable PV for stateful workload
persistentVolumeClaim:
  enabled: false
  # name: pv
  # size: 5G
  # storageClassName: topolvm-provisioner
